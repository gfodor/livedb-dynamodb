// Generated by CoffeeScript 1.6.3
(function() {
  var LiveDbDynamoDB, async, castDocToOp, castDocToSnapshot, castOpToDoc, castSnapshotToDoc, decodeValue, docVal, encodeValue, exports, purgeTable, zlib, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  zlib = require('zlib');

  async = require('async');

  _ = require('lodash');

  exports = module.exports = function(dynamodb, options) {
    return new LiveDbDynamoDB(dynamodb, options);
  };

  LiveDbDynamoDB = (function() {
    function LiveDbDynamoDB(dynamodb, s3, options) {
      this.dynamodb = dynamodb;
      this.s3 = s3;
      this.getVersion = __bind(this.getVersion, this);
    }

    LiveDbDynamoDB.prototype.close = function(callback) {};

    LiveDbDynamoDB.prototype.getSnapshot = function(cName, docName, callback) {
      var _this = this;
      return this.dynamodb.getItem({
        TableName: cName,
        Key: {
          id: {
            S: docName
          }
        },
        ConsistentRead: true
      }, function(err, data) {
        if (!data) {
          return callback(err, null);
        } else {
          if (data.Item != null) {
            return _this.s3.getObject({
              Bucket: cName,
              Key: docName
            }, function(err, object) {
              if (!object) {
                return callback(err, null);
              } else {
                return castDocToSnapshot(data.Item, callback);
              }
            });
          } else {
            return callback(null, null);
          }
        }
      });
    };

    LiveDbDynamoDB.prototype.bulkGetSnapshot = function(requests, callback) {
      var cName, docNames, requestItems, results;
      requestItems = {};
      results = {};
      for (cName in requests) {
        docNames = requests[cName];
        requestItems[cName] = {
          Keys: _.map(docNames, function(n) {
            return {
              id: {
                S: n
              }
            };
          }),
          ConsistentRead: true
        };
        results[cName] = {};
      }
      return this.dynamodb.batchGetItem({
        RequestItems: requestItems
      }, function(err, data) {
        if (err) {
          return callback(err);
        }
        return async.each(_.keys(data.Responses), (function(cName, nextMap) {
          return async.map(data.Responses[cName], castDocToSnapshot, function(err, snapshots) {
            var snapshot, _i, _len;
            for (_i = 0, _len = snapshots.length; _i < _len; _i++) {
              snapshot = snapshots[_i];
              results[cName][snapshot.docName] = snapshot;
            }
            return nextMap(err);
          });
        }), (function(err) {
          return callback(err, results);
        }));
      });
    };

    LiveDbDynamoDB.prototype.writeSnapshot = function(cName, docName, data, callback) {
      var _this = this;
      return castSnapshotToDoc(docName, data, function(err, doc) {
        if (err) {
          return callback(err);
        }
        return async.parallel([
          (function(cb) {
            return _this.dynamodb.putItem({
              TableName: cName,
              Item: doc.item
            }, cb);
          }), (function(cb) {
            return _this.s3.putObject({
              Bucket: cName,
              Key: docName,
              Body: doc.object
            }, cb);
          })
        ], callback);
      });
    };

    LiveDbDynamoDB.prototype.getOplogCollectionName = function(cName) {
      return "" + cName + "_ops";
    };

    LiveDbDynamoDB.prototype.writeOp = function(cName, docName, opData, callback) {
      var _this = this;
      return castOpToDoc(docName, opData, function(err, doc) {
        return _this.dynamodb.putItem({
          TableName: _this.getOplogCollectionName(cName),
          Item: doc,
          Expected: {
            op_id: {
              Exists: false
            }
          }
        }, function(err, data) {
          if (!err || ((err.code != null) && err.code === 'ConditionalCheckFailedException')) {
            return callback(null, data);
          } else {
            return callback(err);
          }
        });
      });
    };

    LiveDbDynamoDB.prototype.getVersion = function(cName, docName, callback) {
      return this.dynamodb.query({
        TableName: this.getOplogCollectionName(cName),
        Select: 'SPECIFIC_ATTRIBUTES',
        AttributesToGet: ['v'],
        Limit: 1,
        ConsistentRead: true,
        KeyConditions: {
          doc_id: {
            AttributeValueList: [
              {
                S: docName
              }
            ],
            ComparisonOperator: 'EQ'
          }
        },
        ScanIndexForward: false
      }, function(err, data) {
        if (err || !data || data.Items.length === 0) {
          return callback(err, 0);
        }
        return callback(err, docVal(_.first(data.Items), "v") + 1);
      });
    };

    LiveDbDynamoDB.prototype.getOps = function(cName, docName, start, end, callback) {
      var keyConditions, _ref;
      if (end && start && end < start) {
        _ref = [end, start], start = _ref[0], end = _ref[1];
      }
      keyConditions = {
        doc_id: {
          AttributeValueList: [
            {
              S: docName
            }
          ],
          ComparisonOperator: 'EQ'
        }
      };
      if (end != null) {
        if (end === start) {
          keyConditions.v = {
            AttributeValueList: [
              {
                N: (start + 1).toString()
              }
            ],
            ComparisonOperator: 'EQ'
          };
        } else {
          keyConditions.v = {
            AttributeValueList: [
              {
                N: start.toString()
              }, {
                N: (end - 1).toString()
              }
            ],
            ComparisonOperator: 'BETWEEN'
          };
        }
      } else {
        keyConditions.v = {
          AttributeValueList: [
            {
              N: start.toString()
            }
          ],
          ComparisonOperator: 'GE'
        };
      }
      return this.dynamodb.query({
        TableName: this.getOplogCollectionName(cName),
        Select: 'ALL_ATTRIBUTES',
        ConsistentRead: true,
        KeyConditions: keyConditions,
        ScanIndexForward: true
      }, function(err, data) {
        if (err || !data) {
          return callback(err, []);
        }
        return async.map(data.Items, castDocToOp, callback);
      });
    };

    LiveDbDynamoDB.prototype.purgeDocTable = function(name, readCapacity, writeCapacity, bucketLocation, cb) {
      var _this = this;
      return purgeTable(this.dynamodb, {
        TableName: name,
        AttributeDefinitions: [
          {
            AttributeName: "id",
            AttributeType: "S"
          }
        ],
        KeySchema: [
          {
            AttributeName: "id",
            KeyType: "HASH"
          }
        ],
        ProvisionedThroughput: {
          ReadCapacityUnits: readCapacity,
          WriteCapacityUnits: writeCapacity
        }
      }, function() {
        return _this.s3.createBucket({
          Bucket: name,
          CreateBucketConfiguration: {
            LocationConstraint: bucketLocation
          }
        }, cb);
      });
    };

    LiveDbDynamoDB.prototype.purgeOpsTable = function(name, readCapacity, writeCapacity, cb) {
      return purgeTable(this.dynamodb, {
        TableName: name,
        AttributeDefinitions: [
          {
            AttributeName: "doc_id",
            AttributeType: "S"
          }, {
            AttributeName: "v",
            AttributeType: "N"
          }
        ],
        KeySchema: [
          {
            AttributeName: "doc_id",
            KeyType: "HASH"
          }, {
            AttributeName: "v",
            KeyType: "RANGE"
          }
        ],
        ProvisionedThroughput: {
          ReadCapacityUnits: readCapacity,
          WriteCapacityUnits: writeCapacity
        }
      }, cb);
    };

    return LiveDbDynamoDB;

  })();

  purgeTable = function(db, tableDefinition, cb) {
    var initTable, tableName;
    tableName = tableDefinition.TableName;
    initTable = function(err, initDone) {
      return db.createTable(tableDefinition, function(err, data) {
        var tablePending;
        if (err) {
          return cb(err);
        }
        tablePending = true;
        return async.whilst((function() {
          return tablePending;
        }), (function(done) {
          return db.describeTable({
            TableName: tableName
          }, function(err, tableInfo) {
            tablePending = (tableInfo == null) || tableInfo.Table.TableStatus !== 'ACTIVE';
            if (tablePending) {
              return setTimeout(done, 1000);
            } else {
              return done();
            }
          });
        }), initDone);
      });
    };
    return db.listTables(function(err, data) {
      if (_.contains(data != null ? data.TableNames : void 0, tableName)) {
        return db.deleteTable({
          TableName: tableName
        }, function(err, data) {
          var tableExists;
          tableExists = true;
          return async.whilst((function() {
            return tableExists;
          }), (function(done) {
            return db.describeTable({
              TableName: tableName
            }, function(err, tableInfo) {
              tableExists = tableInfo != null;
              if (tableExists) {
                return setTimeout(done, 1000);
              } else {
                return done();
              }
            });
          }), (function(err) {
            return initTable(err, cb);
          }));
        });
      } else {
        return initTable(null, cb);
      }
    });
  };

  castOpToDoc = function(docName, opData, cb) {
    var opV;
    opData = _.clone(opData);
    opV = opData.v;
    return encodeValue(opData, function(err, encodedData) {
      if (err) {
        return cb(err);
      }
      return cb(err, {
        doc_id: {
          S: docName
        },
        op_id: {
          S: "" + docName + "_" + opV
        },
        v: {
          N: opV.toString()
        },
        data: {
          B: encodedData.toString('base64')
        }
      });
    });
  };

  castDocToOp = function(doc, cb) {
    if (!doc) {
      return cb(null);
    }
    return decodeValue(docVal(doc, "data"), cb);
  };

  castSnapshotToDoc = function(docName, data, cb) {
    return encodeValue(data.data, function(err, encodedData) {
      return encodeValue(data.m, function(err, encodedM) {
        var doc;
        if (err) {
          return cb(err);
        }
        doc = {
          item: {
            id: {
              S: docName
            },
            type: {
              S: (data.type || "").toString()
            },
            v: {
              N: data.v.toString()
            },
            m: {
              B: encodedM.toString('base64')
            },
            data: {
              B: encodedData.toString('base64')
            }
          },
          object: encodedData
        };
        return cb(err, doc);
      });
    });
  };

  castDocToSnapshot = function(doc, cb) {
    if (!doc) {
      return cb(null);
    }
    return decodeValue(docVal(doc, "data"), function(err, data) {
      return decodeValue(docVal(doc, "m"), function(err, m) {
        var snapshot, type, v;
        if (err) {
          return cb(err);
        }
        snapshot = {
          docName: docVal(doc, "id"),
          v: null,
          type: null,
          data: null,
          m: null
        };
        type = docVal(doc, "type");
        v = docVal(doc, "v");
        if ((type != null) && type !== "") {
          snapshot.type = type;
        }
        if ((v != null) && v !== "") {
          snapshot.v = v;
        }
        if (data != null) {
          snapshot.data = data;
        }
        if (m != null) {
          snapshot.m = m;
        }
        return cb(err, snapshot);
      });
    });
  };

  decodeValue = function(v, cb) {
    return zlib.inflate(v, function(err, inflated) {
      var value;
      if (err) {
        return cb(err, null);
      } else {
        value = inflated.length > 0 ? JSON.parse(inflated) : null;
        return cb(null, value);
      }
    });
  };

  encodeValue = function(v, cb) {
    if (v === null) {
      return cb(null, null);
    }
    return zlib.deflate(JSON.stringify(v), function(err, deflated) {
      if (err) {
        return cb(err, null);
      } else {
        return cb(null, deflated);
      }
    });
  };

  docVal = function(doc, attr) {
    var attribute, type, value;
    attribute = doc[attr];
    type = _.first(_.keys(attribute));
    value = attribute[type];
    if (type === 'N') {
      if (value === "") {
        return null;
      } else {
        return _.parseInt(value);
      }
    } else if (type === 'B') {
      return new Buffer(value, 'base64');
    } else {
      return value;
    }
  };

}).call(this);
