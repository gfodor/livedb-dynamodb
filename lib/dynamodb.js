// Generated by CoffeeScript 1.6.3
(function() {
  var LiveDbDynamoDB, async, castDocToSnapshot, castItemToOp, castOpToDoc, castSnapshotToDoc, decodeValue, docVal, encodeValue, exports, purgeTable, zlib, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  zlib = require('zlib');

  async = require('async');

  _ = require('lodash');

  exports = module.exports = function(dynamodb, s3, options) {
    return new LiveDbDynamoDB(dynamodb, s3, options);
  };

  LiveDbDynamoDB = (function() {
    function LiveDbDynamoDB(dynamodb, s3, options) {
      this.dynamodb = dynamodb;
      this.s3 = s3;
      this.getVersion = __bind(this.getVersion, this);
      if (!options.bucketName) {
        throw new Error("Must specify S3 bucket.");
      }
      this.bucketName = options.bucketName;
    }

    LiveDbDynamoDB.prototype.close = function(callback) {};

    LiveDbDynamoDB.prototype.getSnapshot = function(cName, docName, callback) {
      var _this = this;
      return this.dynamodb.getItem({
        TableName: cName,
        Key: {
          id: {
            S: docName
          }
        },
        ConsistentRead: true
      }, function(err, data) {
        if (!data) {
          return callback(err, null);
        } else {
          if (data.Item != null) {
            return _this.s3.getObject({
              Bucket: _this.bucketName,
              Key: "" + cName + "/" + docName
            }, function(err, object) {
              if (!object) {
                return callback(err, null);
              } else {
                return castDocToSnapshot(data.Item, object.Body, callback);
              }
            });
          } else {
            return callback(null, null);
          }
        }
      });
    };

    LiveDbDynamoDB.prototype.bulkGetSnapshot = function(requests, callback) {
      var cName, docData, docName, docNames, requestItems, results, s3Requests, _i, _len,
        _this = this;
      requestItems = {};
      results = {};
      docData = {};
      s3Requests = [];
      for (cName in requests) {
        docNames = requests[cName];
        requestItems[cName] = {
          Keys: _.map(docNames, function(n) {
            return {
              id: {
                S: n
              }
            };
          }),
          ConsistentRead: true
        };
        results[cName] = {};
        docData[cName] = {};
        for (_i = 0, _len = docNames.length; _i < _len; _i++) {
          docName = docNames[_i];
          s3Requests.push((function(docName, cName) {
            return function(cb) {
              return _this.s3.getObject({
                Bucket: _this.bucketName,
                Key: "" + cName + "/" + docName
              }, function(err, data) {
                if (err && err.code !== 'NotFound') {
                  return cb(err);
                }
                if ((data != null ? data.Body : void 0) != null) {
                  docData[cName][docName] = data.Body;
                }
                return cb(null);
              });
            };
          })(docName, cName));
        }
      }
      return async.parallelLimit(s3Requests, 16, function(err) {
        if (err) {
          return callback(err);
        }
        return _this.dynamodb.batchGetItem({
          RequestItems: requestItems
        }, function(err, data) {
          if (err) {
            return callback(err);
          }
          return async.each(_.keys(data.Responses), (function(cName, nextMap) {
            return async.map(data.Responses[cName], (function(item, cb) {
              docName = docVal(item, "id");
              return castDocToSnapshot(item, docData[cName][docName], cb);
            }), function(err, snapshots) {
              var snapshot, _j, _len1;
              for (_j = 0, _len1 = snapshots.length; _j < _len1; _j++) {
                snapshot = snapshots[_j];
                results[cName][snapshot.docName] = snapshot;
              }
              return nextMap(err);
            });
          }), (function(err) {
            return callback(err, results);
          }));
        });
      });
    };

    LiveDbDynamoDB.prototype.writeSnapshot = function(cName, docName, data, callback) {
      var _this = this;
      return castSnapshotToDoc(docName, data, function(err, doc) {
        if (err) {
          return callback(err);
        }
        return async.parallel([
          (function(cb) {
            return _this.dynamodb.putItem({
              TableName: cName,
              Item: doc.item
            }, cb);
          }), (function(cb) {
            return _this.s3.putObject({
              Bucket: _this.bucketName,
              Key: "" + cName + "/" + docName,
              Body: doc.object
            }, cb);
          })
        ], callback);
      });
    };

    LiveDbDynamoDB.prototype.getOplogCollectionName = function(cName) {
      return "" + cName + "_ops";
    };

    LiveDbDynamoDB.prototype.writeOp = function(cName, docName, opData, callback) {
      var _this = this;
      return castOpToDoc(docName, opData, function(err, doc) {
        return async.parallel([
          (function(cb) {
            return _this.dynamodb.putItem({
              TableName: _this.getOplogCollectionName(cName),
              Item: doc.item,
              Expected: {
                op_id: {
                  Exists: false
                }
              }
            }, function(err, data) {
              if (!err || ((err.code != null) && err.code === 'ConditionalCheckFailedException')) {
                return cb(null);
              } else {
                return cb(err);
              }
            });
          }), (function(cb) {
            if (doc.object) {
              return _this.s3.putObject({
                Bucket: _this.bucketName,
                Key: "" + (_this.getOplogCollectionName(cName)) + "/" + doc.item.op_id.S,
                Body: doc.object
              }, cb);
            } else {
              return cb(null);
            }
          })
        ], callback);
      });
    };

    LiveDbDynamoDB.prototype.getVersion = function(cName, docName, callback) {
      return this.dynamodb.query({
        TableName: this.getOplogCollectionName(cName),
        Select: 'SPECIFIC_ATTRIBUTES',
        AttributesToGet: ['v'],
        Limit: 1,
        ConsistentRead: true,
        KeyConditions: {
          doc_id: {
            AttributeValueList: [
              {
                S: docName
              }
            ],
            ComparisonOperator: 'EQ'
          }
        },
        ScanIndexForward: false
      }, function(err, data) {
        if (err || !data || data.Items.length === 0) {
          return callback(err, 0);
        }
        return callback(err, docVal(_.first(data.Items), "v") + 1);
      });
    };

    LiveDbDynamoDB.prototype.getOps = function(cName, docName, start, end, callback) {
      var keyConditions, _ref,
        _this = this;
      if (end && start && end < start) {
        _ref = [end, start], start = _ref[0], end = _ref[1];
      }
      keyConditions = {
        doc_id: {
          AttributeValueList: [
            {
              S: docName
            }
          ],
          ComparisonOperator: 'EQ'
        }
      };
      if (end != null) {
        if (end === start) {
          keyConditions.v = {
            AttributeValueList: [
              {
                N: (start + 1).toString()
              }
            ],
            ComparisonOperator: 'EQ'
          };
        } else {
          keyConditions.v = {
            AttributeValueList: [
              {
                N: start.toString()
              }, {
                N: (end - 1).toString()
              }
            ],
            ComparisonOperator: 'BETWEEN'
          };
        }
      } else {
        keyConditions.v = {
          AttributeValueList: [
            {
              N: start.toString()
            }
          ],
          ComparisonOperator: 'GE'
        };
      }
      return this.dynamodb.query({
        TableName: this.getOplogCollectionName(cName),
        Select: 'ALL_ATTRIBUTES',
        ConsistentRead: true,
        KeyConditions: keyConditions,
        ScanIndexForward: true
      }, function(err, data) {
        if (err || !data) {
          return callback(err, []);
        }
        return async.mapLimit(data.Items, 16, (function(item, cb) {
          if (item.data) {
            return castItemToOp(item, cb);
          } else {
            return _this.s3.getObject({
              Bucket: _this.bucketName,
              Key: "" + (_this.getOplogCollectionName(cName)) + "/" + item.op_id.S
            }, function(err, object) {
              if (err) {
                return cb(err, null);
              }
              return decodeValue(object.Body, cb);
            });
          }
        }), callback);
      });
    };

    LiveDbDynamoDB.prototype.purgeDocTable = function(name, readCapacity, writeCapacity, cb) {
      return purgeTable(this.dynamodb, {
        TableName: name,
        AttributeDefinitions: [
          {
            AttributeName: "id",
            AttributeType: "S"
          }
        ],
        KeySchema: [
          {
            AttributeName: "id",
            KeyType: "HASH"
          }
        ],
        ProvisionedThroughput: {
          ReadCapacityUnits: readCapacity,
          WriteCapacityUnits: writeCapacity
        }
      }, cb);
    };

    LiveDbDynamoDB.prototype.purgeOpsTable = function(name, readCapacity, writeCapacity, cb) {
      return purgeTable(this.dynamodb, {
        TableName: name,
        AttributeDefinitions: [
          {
            AttributeName: "doc_id",
            AttributeType: "S"
          }, {
            AttributeName: "v",
            AttributeType: "N"
          }
        ],
        KeySchema: [
          {
            AttributeName: "doc_id",
            KeyType: "HASH"
          }, {
            AttributeName: "v",
            KeyType: "RANGE"
          }
        ],
        ProvisionedThroughput: {
          ReadCapacityUnits: readCapacity,
          WriteCapacityUnits: writeCapacity
        }
      }, cb);
    };

    return LiveDbDynamoDB;

  })();

  purgeTable = function(db, tableDefinition, cb) {
    var initTable, tableName;
    tableName = tableDefinition.TableName;
    initTable = function(err, initDone) {
      return db.createTable(tableDefinition, function(err, data) {
        var tablePending;
        if (err) {
          return cb(err);
        }
        tablePending = true;
        return async.whilst((function() {
          return tablePending;
        }), (function(done) {
          return db.describeTable({
            TableName: tableName
          }, function(err, tableInfo) {
            tablePending = (tableInfo == null) || tableInfo.Table.TableStatus !== 'ACTIVE';
            if (tablePending) {
              return setTimeout(done, 1000);
            } else {
              return done();
            }
          });
        }), initDone);
      });
    };
    return db.listTables(function(err, data) {
      if (_.contains(data != null ? data.TableNames : void 0, tableName)) {
        return db.deleteTable({
          TableName: tableName
        }, function(err, data) {
          var tableExists;
          tableExists = true;
          return async.whilst((function() {
            return tableExists;
          }), (function(done) {
            return db.describeTable({
              TableName: tableName
            }, function(err, tableInfo) {
              tableExists = tableInfo != null;
              if (tableExists) {
                return setTimeout(done, 1000);
              } else {
                return done();
              }
            });
          }), (function(err) {
            return initTable(err, cb);
          }));
        });
      } else {
        return initTable(null, cb);
      }
    });
  };

  castOpToDoc = function(docName, opData, cb) {
    var opV;
    opData = _.clone(opData);
    opV = opData.v;
    return encodeValue(opData, function(err, encodedData) {
      var doc, encodedBase64Data;
      if (err) {
        return cb(err);
      }
      encodedBase64Data = encodedData.toString('base64');
      doc = {
        item: {
          doc_id: {
            S: docName
          },
          op_id: {
            S: "" + docName + "_" + opV
          },
          v: {
            N: opV.toString()
          }
        }
      };
      if (encodedBase64Data.length > 1024 * 32) {
        doc.object = encodedData;
      } else {
        doc.item.data = {
          B: encodedBase64Data
        };
      }
      return cb(err, doc);
    });
  };

  castItemToOp = function(doc, cb) {
    if (!doc) {
      return cb(null);
    }
    return decodeValue(docVal(doc, "data"), cb);
  };

  castSnapshotToDoc = function(docName, data, cb) {
    return encodeValue(data.data, function(err, encodedData) {
      return encodeValue(data.m, function(err, encodedM) {
        var doc;
        if (err) {
          return cb(err);
        }
        doc = {
          item: {
            id: {
              S: docName
            },
            type: {
              S: (data.type || "").toString()
            },
            v: {
              N: data.v.toString()
            },
            m: {
              B: encodedM.toString('base64')
            }
          },
          object: encodedData
        };
        return cb(err, doc);
      });
    });
  };

  castDocToSnapshot = function(doc, object, cb) {
    if (!doc) {
      return cb(null);
    }
    return decodeValue(object, function(err, data) {
      return decodeValue(docVal(doc, "m"), function(err, m) {
        var snapshot, type, v;
        if (err) {
          return cb(err);
        }
        snapshot = {
          docName: docVal(doc, "id"),
          v: null,
          type: null,
          data: null,
          m: null
        };
        type = docVal(doc, "type");
        if (type === "null") {
          type = null;
        }
        v = docVal(doc, "v");
        if ((type != null) && type !== "") {
          snapshot.type = type;
        }
        if ((v != null) && v !== "") {
          snapshot.v = v;
        }
        if (data != null) {
          snapshot.data = data;
        }
        if (m != null) {
          snapshot.m = m;
        }
        return cb(err, snapshot);
      });
    });
  };

  decodeValue = function(v, cb) {
    return zlib.inflate(v, function(err, inflated) {
      var value;
      if (err) {
        return cb(err, null);
      } else {
        value = inflated.length > 0 ? JSON.parse(inflated) : null;
        return cb(null, value);
      }
    });
  };

  encodeValue = function(v, cb) {
    if (v === null) {
      return cb(null, null);
    }
    return zlib.deflate(JSON.stringify(v), function(err, deflated) {
      if (err) {
        return cb(err, null);
      } else {
        return cb(null, deflated);
      }
    });
  };

  docVal = function(doc, attr) {
    var attribute, type, value;
    attribute = doc[attr];
    type = _.first(_.keys(attribute));
    value = attribute[type];
    if (type === 'N') {
      if (value === "") {
        return null;
      } else {
        return _.parseInt(value);
      }
    } else if (type === 'B') {
      return new Buffer(value, 'base64');
    } else {
      return value;
    }
  };

}).call(this);
